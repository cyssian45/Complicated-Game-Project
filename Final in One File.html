<!DOCTYPE html>
<html>
    <head>

        <!-- What appears in the title bar -->
        <title>OSU Racing Game</title>

    </head>

    <body onload="startGame()">
    
<script>

// Course Rectangles
var rects = [[20, 20, 100, 560], [20, 20, 760, 100], [710, 20, 70, 560], [596, 530, 184, 50], [482, 480, 164, 50], [368, 430, 164, 50], [254, 480, 164, 50], [140, 530, 164, 50], [140, 380, 50, 150], [190, 318, 50, 112], [140, 256, 50, 112], [190, 194, 50, 112], [140, 140, 50, 104], [140, 140, 550, 42], [640, 140, 50, 320], [552, 410, 138, 50], [280, 222, 320, 148], [552, 222, 48, 238]];
var finishLine = [330, 222, 8, 148];
var powerUpRectangles = [[60, 60, 20, 20]];

//car variable
var car;

function startGame() 
{
    // Initializes a new car object using its constructor 
    car = new carConstructor(20, 40, "red", 70, 500);
    myGameArea.start();
}

//sets up the game area
var myGameArea = 
{            
    canvas : document.createElement("canvas"),
    
    //Run when webpage opens. Initializes canvas. Sets up the event listeners that look for key presses.
    start : function()
    {
        this.canvas.width = 800;
        this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");

        document.body.insertBefore(this.canvas, document.body.firstChild); 

        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);

        //Event Listeners
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        });

        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        });
    },

    stop : function() {
        clearInterval(this.interval);
    },    

    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
};

//Car constructor. Includes all aspects of the car (see parameters)
function carConstructor(width, height, color, x, y, type)
{
    this.type = type;
    this.width = width;
    this.height = height;
    this.speed = 0;
    this.acceleration = 0;
    this.friction = 0;
    this.angle = 0;
    this.moveAngle = 0;
    this.x = x;
    this.y = y;    
    
    // Update redraws the rectangle with the correct orientation (This controls the rotation of the car)
    this.update = function() 
    {
        ctx = myGameArea.context;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = color;
        ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
        ctx.restore();    
    }
    
    //newPos moves the car forwards and backwards based on the "angle" value
    this.newPos = function() 
    {
        this.speed += this.acceleration;

        if (this.speed > 0) 
        {
            this.speed += this.friction;
        } 
        
        else if (this.speed < 0)
        {
            this.speed -= this.friction;
        }

        this.angle += this.moveAngle * Math.PI / 180;
        this.x += this.speed * Math.sin(this.angle);
        this.y -= this.speed * Math.cos(this.angle);
    }

    // Checks that the car doesn't go outside of the 800x600 canvas 
    this.checkEdges = function()
    {
        // Top Edge
        if(this.x <= 0 ) 
        {             
            this.speed = 0;
            this.x = 0;
        }

        // Bottom Edge
        if(this.y >= myGameArea.canvas.height) 
        { 
            this.speed = 0;
            this.y = myGameArea.canvas.height;                    
        }

        // Left Edge
        if(this.y <= 0) 
        { 
            this.speed = 0;
            this.y = 0;
        }

        // Right Edge
        if(this.x >= myGameArea.canvas.width) 
        { 
            this.speed = 0;
            this.x = myGameArea.canvas.width;
        }
    }
    
    // Checks if the car would go outside of the 800x600 canvas 
    this.crashCheck = function()
    {
        // Passes in the car object using "this", which refers to the current "context" (instance of the object) 
        // Note to self - Collision is much easier to do if you make the rectangles the walls instead of the paths 
        console.log("----------------");
        console.log("Collision Frame Data: ");
        return isCarOffPath(this);
    }

    // Checks if the car is touching the finish line 
    this.winCheck = function() 
    {
        return false;
    }
}

// Rectangles are global variables, so don't need passed in 
function isCarOffPath(car)
{
    // Holds x,y coordinates for 
    var actualCarCoordinates = 
    {
        topLeft: {x: 0, y: 0},
        topRight: {x: 0, y: 0},
        bottomLeft: {x: 0, y: 0},
        bottomRight: {x: 0, y: 0},
        topMiddle: {x: 0, y: 0},
        rightMiddle: {x: 0, y: 0},
        leftMiddle: {x: 0, y: 0},
        bottomMiddle: {x: 0, y: 0}
    }

    // Holds x,y coordinates for 
    var defaultCarCoordinates = 
    {
        topLeft: {x: 0, y: 0},
        topRight: {x: 0, y: 0},
        bottomLeft: {x: 0, y: 0},
        bottomRight: {x: 0, y: 0},
        topMiddle: {x: 0, y: 0},
        rightMiddle: {x: 0, y: 0},
        leftMiddle: {x: 0, y: 0},
        bottomMiddle: {x: 0, y: 0}
    }

    // Calculating default x-values for use in next step 
    defaultCarCoordinates.topLeft.x = defaultCarCoordinates.leftMiddle.x = defaultCarCoordinates.bottomLeft.x = car.x - (car.width / 2); // Left Column
    defaultCarCoordinates.topRight.x = defaultCarCoordinates.rightMiddle.x = defaultCarCoordinates.bottomRight.x = car.x + (car.width / 2); // Right Column
    defaultCarCoordinates.topMiddle.x = defaultCarCoordinates.bottomMiddle.x = car.x; // Middle Column

    // Calculating default y-values for use in next step 
    defaultCarCoordinates.topLeft.y = defaultCarCoordinates.topMiddle.y = defaultCarCoordinates.topRight.y = car.y - (car.height / 2); // Top Row
    defaultCarCoordinates.bottomLeft.y = defaultCarCoordinates.bottomMiddle.y = defaultCarCoordinates.bottomRight.y = car.y + (car.height / 2); // Bottom Row
    defaultCarCoordinates.leftMiddle.y = defaultCarCoordinates.rightMiddle.y = car.y; // Middle Row 
    
    // Determining correct corners using trig trsnformation 
    actualCarCoordinates.topLeft.x = car.x + (defaultCarCoordinates.topLeft.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.topLeft.y - car.y) * Math.sin(car.angle);
    actualCarCoordinates.topLeft.y = car.y - (defaultCarCoordinates.topLeft.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.topLeft.y - car.y) * Math.cos(car.angle);  
    actualCarCoordinates.topRight.x = car.x + (defaultCarCoordinates.topRight.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.topRight.y - car.y) * Math.sin(car.angle);
    actualCarCoordinates.topRight.y = car.y - (defaultCarCoordinates.topRight.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.topRight.y - car.y) * Math.cos(car.angle);  
    actualCarCoordinates.bottomLeft.x = car.x + (defaultCarCoordinates.bottomLeft.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.bottomLeft.y - car.y) * Math.sin(car.angle);
    actualCarCoordinates.bottomLeft.y = car.y - (defaultCarCoordinates.bottomLeft.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.bottomLeft.y - car.y) * Math.cos(car.angle); 
    actualCarCoordinates.bottomRight.x = car.x + (defaultCarCoordinates.bottomRight.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.bottomRight.y - car.y) * Math.sin(car.angle); 
    actualCarCoordinates.bottomRight.y = car.y - (defaultCarCoordinates.bottomRight.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.bottomRight.y - car.y) * Math.cos(car.angle);

    // Determining correct midpoint using trig transformation 
    actualCarCoordinates.topMiddle.x = car.x + (defaultCarCoordinates.topMiddle.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.topMiddle.y - car.y) * Math.sin(car.angle);
    actualCarCoordinates.topMiddle.y = car.y - (defaultCarCoordinates.topMiddle.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.topMiddle.y - car.y) * Math.cos(car.angle);  
    actualCarCoordinates.leftMiddle.x = car.x + (defaultCarCoordinates.leftMiddle.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.leftMiddle.y - car.y) * Math.sin(car.angle);
    actualCarCoordinates.leftMiddle.y = car.y - (defaultCarCoordinates.leftMiddle.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.leftMiddle.y - car.y) * Math.cos(car.angle);  
    actualCarCoordinates.rightMiddle.x = car.x + (defaultCarCoordinates.rightMiddle.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.rightMiddle.y - car.y) * Math.sin(car.angle);
    actualCarCoordinates.rightMiddle.y = car.y - (defaultCarCoordinates.rightMiddle.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.rightMiddle.y - car.y) * Math.cos(car.angle); 
    actualCarCoordinates.bottomMiddle.x = car.x + (defaultCarCoordinates.bottomMiddle.x - car.x) * Math.cos(car.angle) + (defaultCarCoordinates.bottomMiddle.y - car.y) * Math.sin(car.angle); 
    actualCarCoordinates.bottomMiddle.y = car.y - (defaultCarCoordinates.bottomMiddle.x - car.x) * Math.sin(car.angle) + (defaultCarCoordinates.bottomMiddle.y - car.y) * Math.cos(car.angle);

    // Assumed to not crash until it does crash 
    let isCarOffPath = true;

    if (allCarPointsAreInsideARectangle(actualCarCoordinates))
    {
        isCarOffPath = false;
    }

    if (isCarOffPath)
    {
        console.log(actualCarCoordinates);
    }

    return isCarOffPath;
}

function allCarPointsAreInsideARectangle(carCoordinates)
{
    let allCarPointsAreInsideARectangle = true;

    // Top-Left, Top-Middle, Top-Right
    if (!isPointInsideARectangle(carCoordinates.topLeft.x, carCoordinates.topLeft.y)) { allCarPointsAreInsideARectangle = false; }
    else if (!isPointInsideARectangle(carCoordinates.topMiddle.x, carCoordinates.topMiddle.y)) { allCarPointsAreInsideARectangle = false; }
    else if (!isPointInsideARectangle(carCoordinates.topRight.x, carCoordinates.topRight.y)) { allCarPointsAreInsideARectangle = false; }

    // Middle-Left, Middle-Right
    else if (!isPointInsideARectangle(carCoordinates.leftMiddle.x, carCoordinates.leftMiddle.y)) { allCarPointsAreInsideARectangle = false; }
    else if (!isPointInsideARectangle(carCoordinates.rightMiddle.x, carCoordinates.rightMiddle.y)) { allCarPointsAreInsideARectangle = false; }

    // Bottom-Left, Bottom-Middle, Bottom-Right
    else if (!isPointInsideARectangle(carCoordinates.bottomLeft.x, carCoordinates.bottomLeft.y)) { allCarPointsAreInsideARectangle = false; }
    else if (!isPointInsideARectangle(carCoordinates.bottomMiddle.x, carCoordinates.bottomMiddle.y)) { allCarPointsAreInsideARectangle = false; }
    else if (!isPointInsideARectangle(carCoordinates.bottomRight.x, carCoordinates.bottomRight.y)) { allCarPointsAreInsideARectangle = false; }

    return allCarPointsAreInsideARectangle;
}

function isPointInsideARectangle(x, y)
{
    let rectangleMinX, rectangleMaxX, rectangleMinY, rectangleMaxY;
    let isPointInsideARectangle = false;

    // Iterates through each rectangle on the course 
    for (let i = 0; i < rects.length; i++)
    {
        // Determining the bounds for the rectangle 
        rectangleMinX = rects[i][0];
        rectangleMaxX = rects[i][0] + rects[i][2];
        rectangleMinY = rects[i][1];
        rectangleMaxY = rects[i][1] + rects[i][3];

        if (x >= rectangleMinX && x <= rectangleMaxX && y >= rectangleMinY && y <= rectangleMaxY)
        {
            isPointInsideARectangle = true;
            break;
        }
    }

    return isPointInsideARectangle;
}

// Processed the next "frame" of the game - Similar to a draw loop in a game. 
// See setInterval in the constructor for how frequently this is called. 
function updateGameArea()
{
    if (car.crashCheck())
    {
        myGameArea.context.fillStyle = "#000000";
        myGameArea.context.font = "30px Arial";
        myGameArea.context.fillText("Game Over", 30, 50);
        return;
    }
    
    if (car.winCheck()) 
    {
        myGameArea.context.fillStyle = "#000000";
        myGameArea.context.font = "30px Arial";
        myGameArea.context.fillText("You Won!", 10, 50);
        return;
    }

    // Clears the board
    myGameArea.clear();

    // Drawing all the rectangles that make up the course
    myGameArea.context.fillStyle = "#808080";
    for (let i = 0; i < rects.length; ++i) 
    {
        myGameArea.context.fillRect(rects[i][0], rects[i][1], rects[i][2], rects[i][3]);
    }

    myGameArea.context.fillStyle = "#000000";

    // Drawing the finish line 
    myGameArea.context.fillRect(finishLine[0], finishLine[1], finishLine[2], finishLine[3]);
    
    // Resets the car's current turning direction every frame
    car.moveAngle = 0;

    // Draws the rectangles for the powerups 
    for (let i = 0; i < powerUpRectangles.length; i++)
    {
        myGameArea.context.fillStyle = "rgb(0, 191, 255)";
        myGameArea.context.fillRect(powerUpRectangles[i][0], powerUpRectangles[i][1], powerUpRectangles[i][2], powerUpRectangles[i][3]);
    }

    //car.speed = 0; ***Leave this commented***
    //Depending on which key is pressed, the appropriate value is adjusted
    if (myGameArea.keys && myGameArea.keys[65]) 
    {
        car.moveAngle = -2; 
    }
    
    if (myGameArea.keys && myGameArea.keys[68]) 
    {
        car.moveAngle = 2;
    }
    
    if (myGameArea.keys && myGameArea.keys[87]) 
    {
        car.acceleration += .001; 
        car.friction = 0;
    } 
    
    else if (myGameArea.keys && myGameArea.keys[83]) 
    {
        car.acceleration += -.001; 
        car.friction = 0;
    } 
    
    else 
    {
        car.acceleration = 0;
        car.friction += -.00005;
    }
    
    //These adjusted values are then used in newPos and update to redraw the new car
    car.newPos();
    car.checkEdges();
    car.update();
}

</script>

    </body>
</html>