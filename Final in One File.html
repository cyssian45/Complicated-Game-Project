<!DOCTYPE html>
<html>
    <head>

        <!-- What appears in the title bar -->
        <title>OSU Racing Game</title>

    </head>

    <body onload="startGame()">
    
<script>

// Course Rectangles
var rects = [[20, 20, 100, 560], [20, 20, 760, 100], [710, 20, 70, 560], [596, 530, 184, 50], [482, 480, 164, 50], [368, 430, 164, 50], [254, 480, 164, 50], [140, 530, 164, 50], [140, 380, 50, 150], [190, 318, 50, 112], [140, 256, 50, 112], [190, 194, 50, 112], [140, 140, 50, 104], [140, 140, 550, 42], [640, 140, 50, 320], [552, 410, 138, 50], [280, 222, 320, 148], [552, 222, 48, 238]];
var finishLine = [330, 222, 8, 148];
var powerUpRectangles = [[60, 60, 20, 20]];

//car variable
var car;

function startGame() 
{
    // Initializes a new car object using its constructor 
    car = new carConstructor(20, 40, "red", 70, 500);
    myGameArea.start();
}

//sets up the game area
var myGameArea = 
{            
    canvas : document.createElement("canvas"),
    
    //Run when webpage opens. Initializes canvas. Sets up the event listeners that look for key presses.
    start : function()
    {
        this.canvas.width = 800;
        this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");

        document.body.insertBefore(this.canvas, document.body.firstChild); 

        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);

        //Event Listeners
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        });

        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        });
    },

    stop : function() {
        clearInterval(this.interval);
    },    

    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
};

//Car constructor. Includes all aspects of the car (see parameters)
function carConstructor(width, height, color, x, y, type)
{
    this.type = type;
    this.width = width;
    this.height = height;
    this.speed = 0;
    this.acceleration = 0;
    this.friction = 0;
    this.angle = 0;
    this.moveAngle = 0;
    this.x = x;
    this.y = y;    
    
    // Update redraws the rectangle with the correct orientation (This controls the rotation of the car)
    this.update = function() 
    {
        ctx = myGameArea.context;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = color;
        ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
        ctx.restore();    
    }
    
    //newPos moves the car forwards and backwards based on the "angle" value
    this.newPos = function() 
    {
        this.speed += this.acceleration;

        if (this.speed > 0) 
        {
            this.speed += this.friction;
        } 
        
        else if (this.speed < 0)
        {
            this.speed -= this.friction;
        }

        this.angle += this.moveAngle * Math.PI / 180;
        this.x += this.speed * Math.sin(this.angle);
        this.y -= this.speed * Math.cos(this.angle);
    }

    // Checks that the car doesn't go outside of the 800x600 canvas 
    this.checkEdges = function()
    {
        // Top Edge
        if(this.x <= 0 ) 
        {             
            this.speed = 0;
            this.x = 0;
        }

        // Bottom Edge
        if(this.y >= myGameArea.canvas.height) 
        { 
            this.speed = 0;
            this.y = myGameArea.canvas.height;                    
        }

        // Left Edge
        if(this.y <= 0) 
        { 
            this.speed = 0;
            this.y = 0;
        }

        // Right Edge
        if(this.x >= myGameArea.canvas.width) 
        { 
            this.speed = 0;
            this.x = myGameArea.canvas.width;
        }
    }
    
    // Checks if the car would go outside of the 800x600 canvas 
    this.crashCheck = function()
    {
        // Passes in the car object using "this", which refers to the current "context" (instance of the object) 
        // Note to self - Collision is much easier to do if you make the rectangles the walls instead of the paths 
        return isCarOffPath(this);
    }

    // Checks if the car is touching the finish line 
    this.winCheck = function() 
    {
        return false;
    }
}

// Rectangles are global variables, so don't need passed in 
function isCarOffPath(car)
{
    // Makes an object holding the car's coordinates 
    // Car coordinates are calculated only once in this method rather than once for every rectangle in the method that this one calls 
    var carCoordinates = 
    {
        topLeftX: 0, 
        topLeftY: 0, 
        topRightX: 0, 
        topRightY: 0,
        bottomLeftX: 0, 
        bottomLeftY: 0, 
        bottomRightX: 0,
        bottomRightY: 0
    }

    // Declaring the values 
    let defaultUpperLeftX, defaultUpperRightX, defaultLowerLeftX, defaultLowerRightX;
    let defaultUpperLeftY, defaultUpperRightY, defaultLowerLeftY, defaultLowerRightY;

    // Calculating where the points would be with no rotation as a reference point for the trig calculation 
    // X-Coordinates
    defaultUpperLeftX = defaultLowerLeftX = car.x - (car.width / 2); 
    defaultUpperRightX = defaultLowerRightX = car.x + (car.width / 2); 

    // Y-Coordinates 
    defaultUpperLeftY = defaultUpperRightY = car.y - (car.height / 2);
    defaultLowerLeftY = defaultLowerRightY = car.y + (car.height / 2); 
    
    // Transforming where the point would usually be to where it is now using some trig transformations and linear algebra (you don't need to understand this) 
    // See https://math.stackexchange.com/questions/384186/calculate-new-positon-of-rectangle-corners-based-on-angle for the equation used here 
    carCoordinates.topLeftX = car.x + (defaultUpperLeftX - car.x) * Math.cos(car.angle) + (defaultUpperLeftY - car.y) * Math.sin(car.angle);
    carCoordinates.topLeftY = car.y - (defaultUpperLeftX - car.x) * Math.sin(car.angle) + (defaultUpperLeftY - car.y) * Math.cos(car.angle);  
    carCoordinates.topRightX = car.x + (defaultUpperRightX - car.x) * Math.cos(car.angle) + (defaultUpperRightY - car.y) * Math.sin(car.angle);
    carCoordinates.topRightY = car.y - (defaultUpperRightX - car.x) * Math.sin(car.angle) + (defaultUpperRightY - car.y) * Math.cos(car.angle);  
    carCoordinates.bottomLeftX = car.x + (defaultLowerLeftX - car.x) * Math.cos(car.angle) + (defaultLowerLeftY - car.y) * Math.sin(car.angle);
    carCoordinates.bottomLeftY = car.y - (defaultLowerLeftX - car.x) * Math.sin(car.angle) + (defaultLowerLeftY - car.y) * Math.cos(car.angle); 
    carCoordinates.bottomRightX = car.x + (defaultLowerRightX - car.x) * Math.cos(car.angle) + (defaultLowerRightY - car.y) * Math.sin(car.angle); // I spent two hours debugging a collision issue and the error was that I switched a Y with an X in this line >.<
    carCoordinates.bottomRightY = car.y - (defaultLowerRightX - car.x) * Math.sin(car.angle) + (defaultLowerRightY - car.y) * Math.cos(car.angle);  

    // Assumed to not crash until it does crash 
    let isCarOffPath = true;

    // Iterating through each rectangle and checking for collision with that rectangle
    for (let i = 0; i < rects.length; i++)
    {
        if (isCarInsideRectangle(carCoordinates, rects[i]))
        {
            isCarOffPath = false;
            break;
        }
    }

    return isCarOffPath;
}

// First argument is the car object, second object is an array representing a rectangle 
// Works by figuring out the four (x, y) coordinates that the car corner is at, then figuring out if the current rectangle touches that 
// Car coordinates are calculated beforehand to make this O(n) instead of O(n^2) 
// Todo - Pass the 8 coordinates in as an object to reduce clutter and make the function definition less complex 
function isCarInsideRectangle(carCoordinates, rectangle)
{       
    // Assumes all points are inside the rectangle unless one of the points is found to not be in it 
    let carIsInRectangle = true;

    // Figuring out rectangle bounds 
    let rectangleMinX = rectangle[0];
    let rectangleMaxX = rectangle[0] + rectangle[2];
    let rectangleMinY = rectangle[1];
    let rectangleMaxY = rectangle[1] + rectangle[3];    

    // Checking if the top-left is NOT in the rectangle 
    if (carCoordinates.topLeftX < rectangleMinX || carCoordinates.topLeftX > rectangleMaxX || carCoordinates.topLeftY < rectangleMinY || carCoordinates.topLeftY > rectangleMaxY)
    { 
        carIsInRectangle = false;
    }

    // Checking if the top-right is NOT in the rectangle
    else if (carCoordinates.topRightX < rectangleMinX || carCoordinates.topRightX > rectangleMaxX || carCoordinates.topRightY < rectangleMinY || carCoordinates.topRightY > rectangleMaxY)
    {        
        carIsInRectangle = false;   
    }

    // Checking if the bottom-left is NOT in the rectangle
    else if (carCoordinates.bottomLeftX < rectangleMinX || carCoordinates.bottomLeftX > rectangleMaxX || carCoordinates.bottomLeftY < rectangleMinY || carCoordinates.bottomLeftY > rectangleMaxY)
    {
        carIsInRectangle = false;
    }

    // Checking if the bottom-right is NOT in the rectangle 
    else if (carCoordinates.bottomRightX < rectangleMinX || carCoordinates.bottomRightX > rectangleMaxX || carCoordinates.bottomRightY < rectangleMinY || carCoordinates.bottomRightY > rectangleMaxY)
    {
        carIsInRectangle = false;
    }

    return carIsInRectangle;
}

// Processed the next "frame" of the game - Similar to a draw loop in a game. 
// See setInterval in the constructor for how frequently this is called. 
function updateGameArea()
{
    if (car.crashCheck())
    {
        myGameArea.context.fillStyle = "#000000";
        myGameArea.context.font = "30px Arial";
        myGameArea.context.fillText("Game Over", 10, 50);
        return;
    }
    
    if (car.winCheck()) 
    {
        myGameArea.context.fillStyle = "#000000";
        myGameArea.context.font = "30px Arial";
        myGameArea.context.fillText("You Won!", 10, 50);
        return;
    }

    // Clears the board
    myGameArea.clear();

    // Drawing all the rectangles that make up the course
    myGameArea.context.fillStyle = "#808080";
    for (let i = 0; i < rects.length; ++i) 
    {
        myGameArea.context.fillRect(rects[i][0], rects[i][1], rects[i][2], rects[i][3]);
    }

    myGameArea.context.fillStyle = "#000000";

    // Drawing the finish line 
    myGameArea.context.fillRect(finishLine[0], finishLine[1], finishLine[2], finishLine[3]);
    
    // Resets the car's current turning direction every frame
    car.moveAngle = 0;

    // Draws the rectangles for the powerups 
    for (let i = 0; i < powerUpRectangles.length; i++)
    {
        myGameArea.context.fillStyle = "rgb(0, 191, 255)";
        myGameArea.context.fillRect(powerUpRectangles[i][0], powerUpRectangles[i][1], powerUpRectangles[i][2], powerUpRectangles[i][3]);
    }

    //car.speed = 0; ***Leave this commented***
    //Depending on which key is pressed, the appropriate value is adjusted
    if (myGameArea.keys && myGameArea.keys[65]) 
    {
        car.moveAngle = -2; 
    }
    
    if (myGameArea.keys && myGameArea.keys[68]) 
    {
        car.moveAngle = 2;
    }
    
    if (myGameArea.keys && myGameArea.keys[87]) 
    {
        car.acceleration += .001; 
        car.friction = 0;
    } 
    
    else if (myGameArea.keys && myGameArea.keys[83]) 
    {
        car.acceleration += -.001; 
        car.friction = 0;
    } 
    
    else 
    {
        car.acceleration = 0;
        car.friction += -.00005;
    }
    
    //These adjusted values are then used in newPos and update to redraw the new car
    car.newPos();
    car.checkEdges();
    car.update();
}

</script>

    </body>
</html>
